{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastApi-MQTT \u00b6 Extension \u00b6 MQTT is a lightweight publish/subscribe messaging protocol designed for M2M (machine to machine) telemetry in low bandwidth environments. Fastapi-mqtt is the client for working with MQTT. For more information about MQQT, please refer to here: MQTT Fatapi-mqtt wraps around gmqtt module. Gmqtt Python async client for MQTT client implementation. Module has support of MQTT version 5.0 protocol Badges \u00b6 Available Features \u00b6 MQTT specification avaliable with help decarator methods using callbacks: on_connect() on_disconnect() on_subscribe() on_message() Base Settings available with pydantic class: Authetication to broker with credentials unsubscribe certain topics and publish to certain topics","title":"FastApi MQTT"},{"location":"#fastapi-mqtt","text":"","title":"FastApi-MQTT"},{"location":"#extension","text":"MQTT is a lightweight publish/subscribe messaging protocol designed for M2M (machine to machine) telemetry in low bandwidth environments. Fastapi-mqtt is the client for working with MQTT. For more information about MQQT, please refer to here: MQTT Fatapi-mqtt wraps around gmqtt module. Gmqtt Python async client for MQTT client implementation. Module has support of MQTT version 5.0 protocol","title":"Extension"},{"location":"#badges","text":"","title":"Badges"},{"location":"#available-features","text":"MQTT specification avaliable with help decarator methods using callbacks: on_connect() on_disconnect() on_subscribe() on_message() Base Settings available with pydantic class: Authetication to broker with credentials unsubscribe certain topics and publish to certain topics","title":"Available Features"},{"location":"contribute/","text":"Contributing to fastapi-mqtt \u00b6 We welcome contributions to fastapi-mqtt Issues \u00b6 Feel free to submit issues and enhancement requests. Fatapi-MQTT Issues Contributing \u00b6 Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes Before get in to the repo and type: \u00b6 $ bash fastapi-mqtt.sh install $ source .venv/bin/activate $ cat app.py uvicorn app:app --port 8000 --reload NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Contirbution"},{"location":"contribute/#contributing-to-fastapi-mqtt","text":"We welcome contributions to fastapi-mqtt","title":"Contributing to fastapi-mqtt"},{"location":"contribute/#issues","text":"Feel free to submit issues and enhancement requests. Fatapi-MQTT Issues","title":"Issues"},{"location":"contribute/#contributing","text":"Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes","title":"Contributing"},{"location":"contribute/#before-get-in-to-the-repo-and-type","text":"$ bash fastapi-mqtt.sh install $ source .venv/bin/activate $ cat app.py uvicorn app:app --port 8000 --reload NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Before get in to the repo and type:"},{"location":"example/","text":"Full example \u00b6 @app.on_event(\"startup\") async def startapp(): await mqtt.connection() @app.on_event(\"shutdown\") async def shutdown(): await mqtt.client.disconnect() @mqtt.on_connect() def connect(client, flags, rc, properties): mqtt.client.subscribe(\"/mqtt\") #subscribing mqtt topic print(\"Connected: \", client, flags, rc, properties) @mqtt.on_message() async def message(client, topic, payload, qos, properties): print(\"Received message: \",topic, payload.decode(), qos, properties) return 0 @mqtt.on_disconnect() def disconnect(client, packet, exc=None): print(\"Disconnected\") @mqtt.on_subscribe() def subscribe(client, mid, qos, properties): print(\"subscribed\", client, mid, qos, properties) @app.get(\"/\") async def func(): await fast_mqtt.publish(\"/mqtt\", \"Hello from Fastapi\") #publishing mqtt topic return {\"result\": True,\"message\":\"Published\" }","title":"Example"},{"location":"example/#full-example","text":"@app.on_event(\"startup\") async def startapp(): await mqtt.connection() @app.on_event(\"shutdown\") async def shutdown(): await mqtt.client.disconnect() @mqtt.on_connect() def connect(client, flags, rc, properties): mqtt.client.subscribe(\"/mqtt\") #subscribing mqtt topic print(\"Connected: \", client, flags, rc, properties) @mqtt.on_message() async def message(client, topic, payload, qos, properties): print(\"Received message: \",topic, payload.decode(), qos, properties) return 0 @mqtt.on_disconnect() def disconnect(client, packet, exc=None): print(\"Disconnected\") @mqtt.on_subscribe() def subscribe(client, mid, qos, properties): print(\"subscribed\", client, mid, qos, properties) @app.get(\"/\") async def func(): await fast_mqtt.publish(\"/mqtt\", \"Hello from Fastapi\") #publishing mqtt topic return {\"result\": True,\"message\":\"Published\" }","title":"Full example"},{"location":"getting-started/","text":"\ud83d\udd79 Guide \u00b6 After installing the module you setup your FastApi app: Main classes are FastMQTT and MQQTConfig from fastapi import FastAPI from fastapi_mqtt import FastMQTT, MQQTConfig app = FastAPI() mqtt_config = MQQTConfig() mqtt = FastMQTT( config=mqtt_config ) MQQTConfig class \u00b6 class has following attributes host : To connect MQQT broker, defaults to localhost port : To connect MQQT broker, defaults to 1883 ssl : if given and not false, a SSL/TLS transport is created (by default a plain TCP transport is created) If ssl is a ssl.SSLContext object, this context is used to create the transport; if ssl is True, a default context returned from ssl.create_default_context() is used. keepalive : Maximum period in seconds between communications with the broker. If no other messages are being exchanged, this controls the rate at which the client will send ping messages to the broker the keepalive timeout value for the client. Defaults to 60 seconds. username : username for authentication, defaults to None password : password for authentication, defaults to None version : MQTT broker version to use, defaults to MQTTv50. According to gmqtt.Client if your broker does not support 5.0 protocol version and responds with proper CONNACK reason code, client will downgrade to 3.1 and reconnect automatically. reconnect_retries reconnect_delay reconnect_retries && reconnect_delay : By default, connected MQTT client will always try to reconnect in case of lost connections. Number of reconnect attempts is unlimited. If you want to change this behaviour pass reconnect_retries and reconnect_delay with its values. For more info: # https://github.com/wialon/gmqtt#reconnects Last three parameters is used after client disconnects abnormally param :: will_message_topic : Topic of the payload param :: will_message_payload : The payload param :: will_delay_interval : Delay interval will_message_topic will_message_payload will_delay_interval FastMQTT client \u00b6 client object to establish connection parametrs beforeconnect and manipulate MQTT service. FastMQTT params \u00b6 client has following parametrs. The class object holds session information necesseary to connect MQTT broker. config : MQQTConfig config class client_id : unique identfiyer for connection to MQQT broker clean_session : The clean session flag tells the broker whether the client wants to establish \\ a persistent session or not. In a persistent session clean_session = False, the broker stores all subscriptions for the client and \\ all missed messages for the client that subscribed with a Quality of Service (QoS) level 1 or 2. \\ If the session is not persistent (clean_session = True),the broker does not store anything for the client and \\ purges all information from any previous persistent session.The client_id that the client provides when it establishes connection to the broker identifies the session., optimistic_acknowledgement","title":"\ud83d\udd79 Getting Started"},{"location":"getting-started/#guide","text":"After installing the module you setup your FastApi app: Main classes are FastMQTT and MQQTConfig from fastapi import FastAPI from fastapi_mqtt import FastMQTT, MQQTConfig app = FastAPI() mqtt_config = MQQTConfig() mqtt = FastMQTT( config=mqtt_config )","title":"\ud83d\udd79 Guide"},{"location":"getting-started/#mqqtconfig-class","text":"class has following attributes host : To connect MQQT broker, defaults to localhost port : To connect MQQT broker, defaults to 1883 ssl : if given and not false, a SSL/TLS transport is created (by default a plain TCP transport is created) If ssl is a ssl.SSLContext object, this context is used to create the transport; if ssl is True, a default context returned from ssl.create_default_context() is used. keepalive : Maximum period in seconds between communications with the broker. If no other messages are being exchanged, this controls the rate at which the client will send ping messages to the broker the keepalive timeout value for the client. Defaults to 60 seconds. username : username for authentication, defaults to None password : password for authentication, defaults to None version : MQTT broker version to use, defaults to MQTTv50. According to gmqtt.Client if your broker does not support 5.0 protocol version and responds with proper CONNACK reason code, client will downgrade to 3.1 and reconnect automatically. reconnect_retries reconnect_delay reconnect_retries && reconnect_delay : By default, connected MQTT client will always try to reconnect in case of lost connections. Number of reconnect attempts is unlimited. If you want to change this behaviour pass reconnect_retries and reconnect_delay with its values. For more info: # https://github.com/wialon/gmqtt#reconnects Last three parameters is used after client disconnects abnormally param :: will_message_topic : Topic of the payload param :: will_message_payload : The payload param :: will_delay_interval : Delay interval will_message_topic will_message_payload will_delay_interval","title":"MQQTConfig class"},{"location":"getting-started/#fastmqtt-client","text":"client object to establish connection parametrs beforeconnect and manipulate MQTT service.","title":"FastMQTT client"},{"location":"getting-started/#fastmqtt-params","text":"client has following parametrs. The class object holds session information necesseary to connect MQTT broker. config : MQQTConfig config class client_id : unique identfiyer for connection to MQQT broker clean_session : The clean session flag tells the broker whether the client wants to establish \\ a persistent session or not. In a persistent session clean_session = False, the broker stores all subscriptions for the client and \\ all missed messages for the client that subscribed with a Quality of Service (QoS) level 1 or 2. \\ If the session is not persistent (clean_session = True),the broker does not store anything for the client and \\ purges all information from any previous persistent session.The client_id that the client provides when it establishes connection to the broker identifies the session., optimistic_acknowledgement","title":"FastMQTT params"},{"location":"install/","text":"Using pip \u00b6 python3 -m venv .venv source .venv/bin/activate pip install fastapi-mqtt","title":"\ud83d\udd28 Installation"},{"location":"install/#using-pip","text":"python3 -m venv .venv source .venv/bin/activate pip install fastapi-mqtt","title":"Using pip"},{"location":"mqtt/","text":"Short Information \u00b6 Short information about Message Queuing Telemetry Transport We will cover some basics and later on will dive in advance. This information is for beginners and for those who want to gain more knowledge. If you don't have any knowledge of what does MQQT does, go ahead you will get much more. MQTT stands for Message Queuing Telemetry Transport. The protocol was invented by IBM to facilitate machine-to-machine communication. It works on the publish and subscribe model to ensure efficient communication across platforms, and also has a level system for message priority. Currently, this protocol is widely used for IoT and large-scale communication because of its small footprint and minimal bandwidth consumption. In addition, it is designed as a lightweight messaging protocol that uses publish/subscribe operations to exchange data between clients and the server. Furthermore, its small size, low power usage, minimized data packets, and ease of implementation make the protocol ideal for the machine-to-machine or Internet of Things world. The compact header size of MQTT and its QoS (Quality of Service) are geared toward reliable M2M communication at a fundamental level, requiring few workarounds to operate smoothly. QoS in MQTT means that each message has three levels of a check for guaranteed message delivery. The levels increase bandwidth usage as they progress, but higher QoS carries with it assurances at the highest level for critical transmissions. So to sum up above: - It's a lightweight protocol. So, it's easy to implement in software and fast in data transmission. - It's based on a messaging technique. - Minimized data packets. Hence, low network usage. - Low power usage. As a result, it saves the connected device's battery. - It's real-time! That's is specifically what makes it perfect for IoT applications. MQTT Components \u00b6 Broker , which is the server that handles the data transmission between the clients. A topic , which is the place a device wants to put or retrieve a message to/from. The message ( payload ) , which is the data that a device receives when subscribing from a topic or send when publishing to a topic. Publish , is the process a device does to send its message to the broker. Subscribe , where a device does to retrieve a message from the broker. In MQTT a publisher publishes messages on a topic and a subscriber must subscribe to that topic to view the message. MQTT is based on clients and a server. Likewise, the server is the guy who is responsible for handling the client's requests for receiving or sending data between each other. MQTT server is called a broker and the clients are simply the connected devices . When a device (a client) wants to send data to the broker , we call this operation a publish . When a device (a client ) wants to receive data from the broker, we call this operation a subscribe . These clients are publishing and subscribing to topics. So, the broker here is the one that handles the publishing/subscribing actions to the target topics. For instance \u00b6 The device has a temperature sensor. Certainly, it wants to send his readings to the broker. On the other side, a phone/desktop application wants to receive this temperature value. Therefore, 2 things will happen: The device defines the topic it wants to publish on, ex: 'temp', then, it publishes the message 'temperature value'. The phone/desktop application subscribes to the topic 'temp', it receives the message that the device has published, which is the temperature value. Again, the broker's role here is to take the message 'temperature value' and deliver it to the phone/desktop application. Important Points to note \u00b6 Clients do not have addresses like in email systems, and messages are not sent to clients. Messages are published to a broker on a topic. The job of an MQTT broker is to filter messages based on topic and then distribute them to subscribers. A client can receive these messages by subscribing to that topic on the same broker. There is no direct connection between a publisher and a subscriber. All clients can publish (broadcast) and subscribe (receive). MQTT brokers do not normally store messages. MQTT Topic \u00b6 Publishers publish to a broker, and the subscribers subscribe to that same broker and they subscribe to the same topic. They will recive all messages sent by that publisher. Publisher publish throughout the topic and subscribers listen to the same topic retrivers it. Topics are created dynamically when someone subscribes to a topic someone publishes a message to a topic with the retained message set to True. Important Notes \u00b6 Topic names are case sensitive . Use utf8 . Must consit at least one character to be valid . Topics do not need to begin with a / and in fact, stating your topic structure with a / is considered bad practice. Subscribing to Topics \u00b6 The following are all valid topic structures for house with ssensorsin several rooms. It is a desing choice. house/room1/senson1 house/room2/sensor1 house/room2/sensor1 house-room1-sensonr1 house-room2-sensor1 house/room1-sensor1 house/room2-sensor1 When subscribing to multiple topics two wildcard characters can be used. Wildcards can only be used to denote a level or multi-levels i.e: /house/# # (hash character) - multi-level wildcard + (plus character) - single-level wildcard Wildcards \u00b6 The client can subscribe to an individual or multiple topics. For multiple, you can use wild characters - # multi-level wildcard. For single-level - + single-level charter. Wildcards can only be used to denote level or multi-levels: i.e: /house/# and it will basically subscribe you all topics under that level slash house forward Invalid Topic Subscriptions: house+ - Reason no topic level house# - Reason no topic level Using wildcards: Subscribing to topic house/+/main-light which subscribes any of these topics and this time ones below room1, room2 garage covered by + single. You will notice they all end with main-light. Example \u00b6 house/room1/main-light house/room2/main-light house/garage/main-light But it does not cover: house/room1/side-light house/room2/side-light Because it has a side-light, it is not main-light. Publishing to Topics \u00b6 A client can only publish to an individual topic. That is, using wildcards when publishing is not allowed. To publish a message to two topics you need to publish the message twice. MQTT Protocol \u00b6 In comparison to HTTP, MQTT Protocol ensures high delivery guarantees. According to measurements in 3G networks, the throughout of MQTT is 93 times faster than HTTP\u2019s. There are 3 levels of Quality of Services: - At most once: guarantees a best-effort delivery. - At least once: guaranteed that a message will be delivered at least once. But the message can also be delivered more than once. - Exactly once: guarantees that each message is received only once by the counterpart HTTP is a request-response protocol for client-server computing and not always optimized for mobile devices. The main solid benefits of MQTT in these terms are light weightiness (MQTT transfers data as a byte array) and publish/subscribe model, which makes it perfect for resource-constrained devices and helps to save battery. MQTT is a binary-based protocol where the control elements are binary bytes and not text strings. MQTT has a very short message header and the smallest packet message size of 2 bytes. MQTT specification \u00b6 CONNECT PUBLISH SUBSCRIBE UNSUBSCRIBE DISCONNECT Whereas HTTP specifications are much longer.HTTP is worthy and extendable. But MQTT is more suitable when it is referred to as IoT development. MQTT uses a command and command acknowledgment format. That means each command has an associated acknowledgment. Topic names, Client ID, username, and passwords are encoded as UTF-8 strings. The Payload excluding MQTT protocol information like Client ID etc. is binary data and the content and format are application-specific. The fixed header field consists of the control field and the variable-length packet length field. The MQTT packet or message format consists of a 2 byte fixed header (always present) + Variable-header (not always present)+ payload (not always present). It is interesting that the client ID field is sent as the first part of the payload, and not as part of the header. MQTT uses TCP/IP to connect to the broker. TCP is a connection orientated protocol with error correction and guarantees that packets are received in order. References \u00b6 https://github.com/mqtt/mqtt.github.io/wikis https://blogs.windows.com/buildingapps/2016/03/14/when-to-use-a-http-call-instead-of-a-websocket-or-http-2-0/#ojUEP8d4hQBbeDVO.97 http://www.steves-internet-guide.com/mqtt/","title":"MQTT"},{"location":"mqtt/#short-information","text":"Short information about Message Queuing Telemetry Transport We will cover some basics and later on will dive in advance. This information is for beginners and for those who want to gain more knowledge. If you don't have any knowledge of what does MQQT does, go ahead you will get much more. MQTT stands for Message Queuing Telemetry Transport. The protocol was invented by IBM to facilitate machine-to-machine communication. It works on the publish and subscribe model to ensure efficient communication across platforms, and also has a level system for message priority. Currently, this protocol is widely used for IoT and large-scale communication because of its small footprint and minimal bandwidth consumption. In addition, it is designed as a lightweight messaging protocol that uses publish/subscribe operations to exchange data between clients and the server. Furthermore, its small size, low power usage, minimized data packets, and ease of implementation make the protocol ideal for the machine-to-machine or Internet of Things world. The compact header size of MQTT and its QoS (Quality of Service) are geared toward reliable M2M communication at a fundamental level, requiring few workarounds to operate smoothly. QoS in MQTT means that each message has three levels of a check for guaranteed message delivery. The levels increase bandwidth usage as they progress, but higher QoS carries with it assurances at the highest level for critical transmissions. So to sum up above: - It's a lightweight protocol. So, it's easy to implement in software and fast in data transmission. - It's based on a messaging technique. - Minimized data packets. Hence, low network usage. - Low power usage. As a result, it saves the connected device's battery. - It's real-time! That's is specifically what makes it perfect for IoT applications.","title":"Short Information"},{"location":"mqtt/#mqtt-components","text":"Broker , which is the server that handles the data transmission between the clients. A topic , which is the place a device wants to put or retrieve a message to/from. The message ( payload ) , which is the data that a device receives when subscribing from a topic or send when publishing to a topic. Publish , is the process a device does to send its message to the broker. Subscribe , where a device does to retrieve a message from the broker. In MQTT a publisher publishes messages on a topic and a subscriber must subscribe to that topic to view the message. MQTT is based on clients and a server. Likewise, the server is the guy who is responsible for handling the client's requests for receiving or sending data between each other. MQTT server is called a broker and the clients are simply the connected devices . When a device (a client) wants to send data to the broker , we call this operation a publish . When a device (a client ) wants to receive data from the broker, we call this operation a subscribe . These clients are publishing and subscribing to topics. So, the broker here is the one that handles the publishing/subscribing actions to the target topics.","title":"MQTT Components"},{"location":"mqtt/#for-instance","text":"The device has a temperature sensor. Certainly, it wants to send his readings to the broker. On the other side, a phone/desktop application wants to receive this temperature value. Therefore, 2 things will happen: The device defines the topic it wants to publish on, ex: 'temp', then, it publishes the message 'temperature value'. The phone/desktop application subscribes to the topic 'temp', it receives the message that the device has published, which is the temperature value. Again, the broker's role here is to take the message 'temperature value' and deliver it to the phone/desktop application.","title":"For instance"},{"location":"mqtt/#important-points-to-note","text":"Clients do not have addresses like in email systems, and messages are not sent to clients. Messages are published to a broker on a topic. The job of an MQTT broker is to filter messages based on topic and then distribute them to subscribers. A client can receive these messages by subscribing to that topic on the same broker. There is no direct connection between a publisher and a subscriber. All clients can publish (broadcast) and subscribe (receive). MQTT brokers do not normally store messages.","title":"Important Points to note"},{"location":"mqtt/#mqtt-topic","text":"Publishers publish to a broker, and the subscribers subscribe to that same broker and they subscribe to the same topic. They will recive all messages sent by that publisher. Publisher publish throughout the topic and subscribers listen to the same topic retrivers it. Topics are created dynamically when someone subscribes to a topic someone publishes a message to a topic with the retained message set to True.","title":"MQTT Topic"},{"location":"mqtt/#important-notes","text":"Topic names are case sensitive . Use utf8 . Must consit at least one character to be valid . Topics do not need to begin with a / and in fact, stating your topic structure with a / is considered bad practice.","title":"Important Notes"},{"location":"mqtt/#subscribing-to-topics","text":"The following are all valid topic structures for house with ssensorsin several rooms. It is a desing choice. house/room1/senson1 house/room2/sensor1 house/room2/sensor1 house-room1-sensonr1 house-room2-sensor1 house/room1-sensor1 house/room2-sensor1 When subscribing to multiple topics two wildcard characters can be used. Wildcards can only be used to denote a level or multi-levels i.e: /house/# # (hash character) - multi-level wildcard + (plus character) - single-level wildcard","title":"Subscribing to Topics"},{"location":"mqtt/#wildcards","text":"The client can subscribe to an individual or multiple topics. For multiple, you can use wild characters - # multi-level wildcard. For single-level - + single-level charter. Wildcards can only be used to denote level or multi-levels: i.e: /house/# and it will basically subscribe you all topics under that level slash house forward Invalid Topic Subscriptions: house+ - Reason no topic level house# - Reason no topic level Using wildcards: Subscribing to topic house/+/main-light which subscribes any of these topics and this time ones below room1, room2 garage covered by + single. You will notice they all end with main-light.","title":"Wildcards"},{"location":"mqtt/#example","text":"house/room1/main-light house/room2/main-light house/garage/main-light But it does not cover: house/room1/side-light house/room2/side-light Because it has a side-light, it is not main-light.","title":"Example"},{"location":"mqtt/#publishing-to-topics","text":"A client can only publish to an individual topic. That is, using wildcards when publishing is not allowed. To publish a message to two topics you need to publish the message twice.","title":"Publishing to Topics"},{"location":"mqtt/#mqtt-protocol","text":"In comparison to HTTP, MQTT Protocol ensures high delivery guarantees. According to measurements in 3G networks, the throughout of MQTT is 93 times faster than HTTP\u2019s. There are 3 levels of Quality of Services: - At most once: guarantees a best-effort delivery. - At least once: guaranteed that a message will be delivered at least once. But the message can also be delivered more than once. - Exactly once: guarantees that each message is received only once by the counterpart HTTP is a request-response protocol for client-server computing and not always optimized for mobile devices. The main solid benefits of MQTT in these terms are light weightiness (MQTT transfers data as a byte array) and publish/subscribe model, which makes it perfect for resource-constrained devices and helps to save battery. MQTT is a binary-based protocol where the control elements are binary bytes and not text strings. MQTT has a very short message header and the smallest packet message size of 2 bytes.","title":"MQTT Protocol"},{"location":"mqtt/#mqtt-specification","text":"CONNECT PUBLISH SUBSCRIBE UNSUBSCRIBE DISCONNECT Whereas HTTP specifications are much longer.HTTP is worthy and extendable. But MQTT is more suitable when it is referred to as IoT development. MQTT uses a command and command acknowledgment format. That means each command has an associated acknowledgment. Topic names, Client ID, username, and passwords are encoded as UTF-8 strings. The Payload excluding MQTT protocol information like Client ID etc. is binary data and the content and format are application-specific. The fixed header field consists of the control field and the variable-length packet length field. The MQTT packet or message format consists of a 2 byte fixed header (always present) + Variable-header (not always present)+ payload (not always present). It is interesting that the client ID field is sent as the first part of the payload, and not as part of the header. MQTT uses TCP/IP to connect to the broker. TCP is a connection orientated protocol with error correction and guarantees that packets are received in order.","title":"MQTT  specification"},{"location":"mqtt/#references","text":"https://github.com/mqtt/mqtt.github.io/wikis https://blogs.windows.com/buildingapps/2016/03/14/when-to-use-a-http-call-instead-of-a-websocket-or-http-2-0/#ojUEP8d4hQBbeDVO.97 http://www.steves-internet-guide.com/mqtt/","title":"References"}]}